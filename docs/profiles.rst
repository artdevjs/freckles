
Those two are the only so-called *profiles* I have implemented so far: ``dotfiles`` and ``python-dev``. *freckles* is written in a way to add more of those profiles fairly easily though, my reasoning being that its a good idea to have a set of 'commonly used', 'best-practices' profile of how code should be structured, and which metadata is necessary to describe certain 'expressions' of that code or data (e.g. a python project could need to be setup in a development environment, or installed from source for 'normal' use).

I haven't finished thinking about all potential pros and cons yet, but so far I think that metadata should sit with the code itself (with a few minor exceptions like for example where on the target machine it should be checked out). Once that is done, we can have systems do things automatically to get the target system in the state that is determined by the code itself, the profile used, and some aspects of the host machine (e.g. which OS is running on it, which package managers are available).

The nice thing about this is that this gives you all the advantages of an automated system to manage your working space, while still allowing flexibiliy in how to deal with certain types of code/data. For example, you don't like the ``stow`` way of symbolically linking dotfiles? Well, just create a profile that sets up your dotfiles using a detached git repostory (XXX link). As long as the repository contains the name of the profile in its metadata, all is good.
